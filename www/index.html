<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" ng-app="financeApp">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analysis it</title>

    <link rel="stylesheet" href="Content/bootstrap.css">

    <script src="Scripts/angular.js"></script>
    <script src="Scripts/angular-ui/ui-bootstrap.js"></script>

    <script src="js/Chart.min.js"></script>
     <script src="js/angular-chart.min.js"></script>

    <script type="text/javascript">
        angular.module("financeApp",  ['chart.js'])
        .value("urlFormat", 'http://chartapi.finance.yahoo.com/instrument/1.0/{StockName}/chartdata;type=quote;range=1d/json?callback=JSON_CALLBACK')
            .value("oneItemUrl", 'http://finance.yahoo.com/webservice/v1/symbols/{StockName}/quote?format=json&callback=JSON_CALLBACK')
            .constant("stockName", "{StockName}")
        .constant('functionName', 'finance_charts_json_callback')

            .service('dateService', function () {
                var body = this;
                body.getEndOfDate = function (startDate, minutes, isFifteen) {
                    var retDate = body.addMinuteToDate(startDate, minutes);
                    if (isFifteen) {
                        while ((retDate.getMinutes() % 15) > 0) {
                            retDate = body.substractMinuteFromDate(retDate, 1);

                        }
                    }
                    return retDate;
                };

                body.getDateWithoutSeconds = function (date) {
                    return new Date(date - (date.getSeconds() * 1000));
                };

                body.substractMinuteFromDate = function (date, minute) {
                    return new Date(date - (minute * 60 * 1000));
                };

                body.addMinuteToDate = function (date, minute) {
                    var newDate = new Date(date);
                    newDate.setMinutes(newDate.getMinutes() + minute);
                    return newDate;
                };

            })
            .service('deferSerialService', function ($q) {
                var service = this;

                service.getDefObj = function (func, data) {
                    var myDef = {};
                    myDef.def = $q.defer();
                    myDef.invoke = function () {
                        func(myDef).then(function () {
                            myDef.def.resolve();
                        });
                    };

                    myDef.then = function (obj) {
                        myDef.def.promise.then(function () {
                            obj.invoke();
                        });
                    };

                    myDef.thenMethod = function (method) {
                        myDef.def.promise.then(function () {
                            method();
                        });
                    };

                    if (data == null) {
                        myDef.data = null;
                    }
                    else {
                        myDef.data = data;
                    }

                    return myDef;
                };

            })
            .service("myModel", function ($http, urlFormat, stockName, functionName, oneItemUrl, $q, $timeout, dateService) {
                var service = this;

                service.getLiveData = function (stock) {
                    var url = oneItemUrl.replace(stockName, stock);

                    return $http.jsonp(url);
                };

                service.getData = function (stock) {
                    var url = urlFormat.replace(stockName, stock);

                    return $http.jsonp(url);
                };
                service.getStockName = function(symbol)
                {
                    var ret = symbol;

                    angular.forEach(service.stocks,function(item,key){
                        
                        if(item.stockSymbol.toLowerCase() == symbol.toLowerCase())
                        {
                            ret =  item.stockName;
                            return false;
                        }
                    });

                    return ret;
                };

                service.stocks = [
                    { stockName: 'EUR/USD', stockSymbol: 'EURUSD=X' },
{ stockName: 'USD/CAD', stockSymbol: 'USDCAD=X' },
{stockName: 'Apple Inc.', stockSymbol: 'AAPL'},
{ stockName: 'AUD/USD', stockSymbol: 'AUDUSD=X' },
{ stockName: 'Snap Inc.', stockSymbol: 'SNAP' },
{ stockName: 'Facebook', stockSymbol: 'FB' },
{ stockName: 'Citigroup, Inc.', stockSymbol: 'C' },
{ stockName: 'Morgan Stanley', stockSymbol: 'MS' },
{ stockName: 'Alphabet Inc. goog', stockSymbol: 'GOOG' },
{ stockName: 'Alphabet Inc. googl', stockSymbol: 'GOOGL' },
{ stockName: 'Alibaba Group Holding Limited A', stockSymbol: 'BABA' },
{ stockName: 'GBP/USD', stockSymbol: 'GBPUSD=X' },
{ stockName: 'Yahoo! Inc.', stockSymbol: 'YHOO' },
{ stockName: 'GBP/JPY', stockSymbol: 'GBPJPY=X' },
{ stockName: 'Cisco Systems, Inc.', stockSymbol: 'CSCO' },
{ stockName: 'Coca-Cola Company (The) Common', stockSymbol: 'KO' },
{ stockName: 'Baidu, Inc.', stockSymbol: 'BIDU' },
{ stockName: 'Intel Corporation', stockSymbol: 'INTC' },
{ stockName: 'Microsoft Corporation', stockSymbol: 'MSFT' },
{ stockName: 'American International Group, I', stockSymbol: 'AIG' },
{ stockName: 'Nike, Inc. Common Stock', stockSymbol: 'NKE' },
{ stockName: 'USD/CHF', stockSymbol: 'USDCHF=X' },
{ stockName: 'GBP/CAD', stockSymbol: 'GBPCAD=X' },
{ stockName: 'EUR/JPY', stockSymbol: 'EURJPY=X' },
{ stockName: 'Goldman Sachs Group, Inc. (The)', stockSymbol: 'GS' },
{ stockName: 'AUD/CAD', stockSymbol: 'AUDCAD=X' },
{ stockName: 'NZD/USD', stockSymbol: 'NZDUSD=X' },
{ stockName: 'Amazon', stockSymbol: 'AMZN' },
{ stockName: 'JP Morgan Chase & Co. Common St', stockSymbol: 'JPM' },
{ stockName: 'EUR/AUD', stockSymbol: 'EURAUD=X' },
{ stockName: 'Tesla', stockSymbol: 'TSLA' },
 { stockName: 'EUR/NZD', stockSymbol: 'EURNZD=X' },
 { stockName: 'GBP/CHF', stockSymbol: 'GBPCHF=X' },
{ stockName: 'CAD/CHF', stockSymbol: 'CADCHF=X' },
                    
                    
                    
                    { stockName: 'EUR/GBP', stockSymbol: 'EURGBP=X' },
                    

                    
                   
                    
                    
                    { stockName: 'AUD/JPY', stockSymbol: 'AUDJPY=X' },
                    
                    
                      { stockName: 'EUR/CAD', stockSymbol: 'EURCAD=X' },
                      
                       { stockName: 'CHF/JPY', stockSymbol: 'CHFJPY=X' },
            { stockName: 'USD/JPY', stockSymbol: 'USDJPY=X' },
            { stockName: 'USD/NOK', stockSymbol: 'USDNOK=X' }
            
           
        
         
        
        
         

                ];

                service.getOneItemData = function (item, config) {
                    var def = $q.defer();

                    var startDate = new Date();
                    var tryNum = 0;
                    var success = function (result) {
                        console.log(result.data);



                        var bindModel = service.analysisData(result.data, item, config);
                        bindModel.startDate = startDate;
                        def.resolve(bindModel);
                    };
                    var fail = function () {
                        if (tryNum > 10) {
                            def.resolve({error : 'No internet for item '+ item +' !'});
                        }
                        else {

                            tryNum++;
                            console.error('fail no ' + tryNum, item);
                            service.getData(item).then(success, fail);
                        }


                    };
                    service.getData(item).then(success,fail );

                    return def.promise;
                };

                service.analysisData = function (data, item, config) {
                    var keydData = {};
                    var last = null;
                    angular.forEach(data.series, function (ser, key) {


                        ser.myDate = new Date(ser.Timestamp * 1000);

                        //get date without seconds
                        var dateMinusSec = dateService.getDateWithoutSeconds(ser.myDate);
                        ser.keyDate = dateMinusSec;
                        if (!keydData[dateMinusSec]) {
                            keydData[dateMinusSec] = ser;
                            keydData[dateMinusSec].closes = [];
                            keydData[dateMinusSec].closes.push(ser.close);
                        }
                        else {
                            keydData[dateMinusSec].closes.push(ser.close);
                        }


                        if (!keydData.first) {
                            keydData.first = keydData[dateMinusSec];
                        }

                        last = keydData[dateMinusSec];
                    });

                    keydData.last = last;

                    //complete gap

                    var lastDataFound = keydData.first;
                    var myDataFirstDate = keydData.first.keyDate;
                    var endDate = last.keyDate;
                    while (myDataFirstDate < endDate) {
                        if (!keydData[myDataFirstDate]) {
                            keydData[myDataFirstDate] = lastDataFound;
                        }
                        else {
                            lastDataFound = keydData[myDataFirstDate];
                        }

                        myDataFirstDate = dateService.addMinuteToDate(myDataFirstDate, 1);
                    }

                    console.log(keydData);

                    //calculate it


                    var startDate = dateService.substractMinuteFromDate(endDate, config.timeMinutes);

                    if (startDate < keydData.first.keyDate || startDate > keydData.last.keyDate)
                        startDate = keydData.first.keyDate;



                    return service.startAnalysisProcess(keydData, startDate, endDate, config, item);
                };


                service.calculateAverageArrays = function(keydData,startDate,endDate,config,item)
                {
                    var ret = {
                          avgArr:[]
                          ,maxArr:[]
                          ,minArr:[]
                          ,dayMax:0
                          ,dayMin:0
                    };

                    var myDate = keydData.first.keyDate;

                    var avg = 0;
                    var count = 0;

                    while(myDate <= endDate)
                    {
                        var close = parseFloat(keydData[myDate].close);

                        avg = avg + close;
                        count = count +1;
                        
                        if(ret.dayMax < close)
                        {
                            ret.dayMax = close;
                        }

                        if(ret.dayMin == 0 || ret.dayMin > close)
                        {
                            ret.dayMin = close;
                        }


                        if(myDate >= startDate)
                        {
                            //we add array values;
                            var currentAvg = avg/count;
                            var currentMax = currentAvg + ((ret.dayMax - currentAvg)/2);
                            var currentMin = currentAvg - ((currentAvg-ret.dayMin)/2);
                            ret.minArr.push(currentMin);
                            ret.avgArr.push(currentAvg);
                            ret.maxArr.push(currentMax);
                        }


                        myDate = dateService.addMinuteToDate(myDate, 1);
                    }



                    return ret;
                }


                service.calculateAvgLine = function(keyData,startDate,endDate,config,item)
                {
                    var myStartDate = startDate;
                    var retArr = [];

                     var minuteCount = (endDate - startDate)/(1000*60);
                   var current  = 0;
                   var direction = false;
                   var starthigh = keyData[startDate].high;
                   var startlow = keyData[startDate].low;
                   var endhigh =  keyData[endDate].high;
                   var endlow = keyData[endDate].low;
                  
                   var allhigh = starthigh;
                   var alllow = endlow;
                   if(starthigh < endhigh)
                   {
                       direction = true;
                       allhigh = endhigh;
                       alllow = startlow;
                   }
                   
                   var size =  allhigh - alllow ;
                   


                 var trendFound = true;
                    current = 1;

                    while(myStartDate<= endDate)
                    {
                       
                        var maxDiffPercentage = 100 - config.alertPercentage;
                        var maxDiff = (size * maxDiffPercentage)/100;
                        var thisMinuteDiff = 0;
                        var oneMinuteSize = size/minuteCount;
                       
                        
                        if(direction)
                        {
                            var currentMinuteSize = (oneMinuteSize * current) + alllow;
                            
                        }
                        else
                        {
                            var currentMinuteSize = (oneMinuteSize *(minuteCount - (current-1))) + alllow;
                            
                        }


                        retArr.push(currentMinuteSize);


                        current = current+1;
                        myStartDate = dateService.addMinuteToDate(myStartDate, 1);
                    }


                    return retArr;
                    



                };

                service.calculateVolumes = function (keyData,startDate,endDate,config,item)
                {
                    var chartObj = {
                            data:[[]],
                            series:['name']
                            ,labels:[]
                            ,dataset:[{ yAxisID: 'y-axis-1' }]
                            ,options:{
                                scales: {
                                        yAxes: [
                                                    {
                                                    id: 'y-axis-1',
                                                    type: 'linear',
                                                    display: true,
                                                    position: 'left'
                                                    }
                                                ]
                                        }
                                    }
                                };

                            var closeChartVar = angular.copy(chartObj);
                            closeChartVar.series[0] = 'close';
                             var volumesChartVar = angular.copy(chartObj);
                            volumesChartVar.series[0] = 'volumes';
                             var ovbChartVar = angular.copy(chartObj);
                           ovbChartVar.series[0] = 'ovb';
                           var enhanceOvbChartVar = angular.copy(chartObj);
                           enhanceOvbChartVar.series[0] = 'enhance_ovb';

                           var dayGraphVar = angular.copy(chartObj);
                           dayGraphVar.series[0] = 'day_graph';

                    
                    var ret = {
                        volumeArr:[]
                        ,avgVolume:0
                        ,ovbArr:[]
                        ,closesArr:[]
                        ,enhanceOvbArr:[]
                        ,averageLineArr:[]
                        ,dayGraphArr:[]
                        ,dayAverageLine:[]
                        ,closesChart:closeChartVar
                        ,volumeChart:volumesChartVar

                        ,ovbChart:ovbChartVar

                    ,enhanceOvbChart:enhanceOvbChartVar
                        ,dayGraph:dayGraphVar
                    };

                 try
                 {
                    var myDate = startDate;
                    var startVolume = 0;
                    var count = 0;
                    var lastClose = 0;
                    var startOvb = 0;
                    var startEnhance = 0;
                   var lastClose = 0;
                    while (myDate <= endDate) {
                        if (parseFloat(keyData[myDate].volume) == 0)
                        {
                            keyData[myDate].volume=1;
                        }
                        ret.volumeArr.push(parseFloat(keyData[myDate].volume));
                        ret.volumeChart.labels.push(myDate.getMinutes().toString());
                        ret.closesArr.push(parseFloat(keyData[myDate].close));
                        ret.closesChart.labels.push(myDate.getMinutes().toString());
                       
                        if(count == 0)
                        {
                            startOvb = parseFloat(keyData[myDate].volume);
                            startEnhance = startOvb;
                        }
                        else
                        {
                            if(lastClose == 0)
                                lastClose = parseFloat(keyData[myDate].open);
                            var close = parseFloat(keyData[myDate].close);

                            if(close > lastClose)
                            {
                                startOvb = startOvb + parseFloat(keyData[myDate].volume);
                            }
                            else if(lastClose > close)
                            {
                                 startOvb = startOvb - parseFloat(keyData[myDate].volume);
                            }

                            
                            //enhance ovb
                            var high = parseFloat(keyData[myDate].high);
                            var low = parseFloat(keyData[myDate].low);
                            var open = lastClose;
                            var volume = parseFloat(keyData[myDate].volume);

                            var mid = (high + low)/2;
                            if(close > mid)
                            {
                                startEnhance = startEnhance + volume;
                            }
                            else if (mid > close)
                            {
                                startEnhance = startEnhance - volume;
                            }

                            
                        }





                        lastClose = parseFloat(keyData[myDate].close);
                        ret.ovbArr.push(startOvb);
                        ret.ovbChart.labels.push(myDate.getMinutes().toString());

                        ret.enhanceOvbArr.push(startEnhance);
                        ret.enhanceOvbChart.labels.push(myDate.getMinutes().toString());

                        startVolume = startVolume + parseFloat(keyData[myDate].volume);
                        count = count +1;

                        myDate = dateService.addMinuteToDate(myDate, 1);



                        
                        

                    }

                    ret.avgVolume = startVolume/count;

                    ret.volumeChart.data = [ret.volumeArr];
                    ret.ovbChart.data = [ret.ovbArr];

                    ret.averageLineArr = service.calculateAvgLine(keyData,startDate,endDate,config,item);
                    ret.dayAverageLine = service.calculateAvgLine(keyData,keyData.first.keyDate,endDate,config,item);

                    if(config.showTodayAverage)
                    {
                       
                        var averageRet = service.calculateAverageArrays(keyData,startDate,endDate,config,item);
                        ret.closesChart.data=[ret.closesArr,averageRet.avgArr,averageRet.maxArr,averageRet.minArr];
                    }
                    else
                    {
                        ret.closesChart.data=[ret.closesArr];
                    }

                    //day graph
                    
                    var myDate = keyData.first.keyDate;
                    while (myDate <= endDate) {
                        
                        ret.dayGraphArr.push(parseFloat(keyData[myDate].close));

                        ret.dayGraph.labels.push(myDate.getMinutes().toString());
                        myDate = dateService.addMinuteToDate(myDate, 1);

                    }

                    ret.dayGraph.data = [ret.dayGraphArr];


                    //averageLine
                    if(config.showAverageLine)
                    {
                        ret.closesChart.data.push(ret.averageLineArr);
                        ret.dayGraph.data.push(ret.dayAverageLine);
                    }

                    
                    ret.enhanceOvbChart.data = [ret.enhanceOvbArr];

                    

                 }
                 catch(Ex)
                 {
                     console.error(ex);
                 }


                    return ret;
                };

                service.startAnalysisProcess = function (keyData, startDate, endDate, config, item) {
                    
                    var high = 0;
                    var equal = 0;
                    var low = 0;
                    var count = 0;
                    var avgUp = 0;
                    var avgDown = 0;

                    var myStartDate = startDate;
                    var myEndDate = dateService.getEndOfDate(myStartDate, config.minutes(), config.endDate15);
                    var myAllData = [];

                   

                   var volumeObj = service.calculateVolumes(keyData,startDate,endDate,config,item);

                   var minuteCount = (endDate - startDate)/(1000*60);
                   var current  = 0;
                   var direction = false;
                   var starthigh = keyData[startDate].high;
                   var startlow = keyData[startDate].low;
                   var endhigh =  keyData[endDate].high;
                   var endlow = keyData[endDate].low;
                  
                   var allhigh = starthigh;
                   var alllow = endlow;
                   if(starthigh < endhigh)
                   {
                       direction = true;
                       allhigh = endhigh;
                       alllow = startlow;
                   }
                   
                   var size =  allhigh - alllow ;
                   


                 var trendFound = true;
                    current = 1;
                    while(myStartDate<= endDate)
                    {
                       
                        var maxDiffPercentage = 100 - config.alertPercentage;
                        var maxDiff = (size * maxDiffPercentage)/100;
                        var thisMinuteDiff = 0;
                        var oneMinuteSize = size/minuteCount;
                       
                        
                        if(direction)
                        {
                            var currentMinuteSize = (oneMinuteSize * current) + alllow;
                            
                        }
                        else
                        {
                            var currentMinuteSize = (oneMinuteSize *(minuteCount - (current-1))) + alllow;
                            
                        }


                        var maxDownSize = currentMinuteSize - maxDiff;
                            var maxUpSize = currentMinuteSize + maxDiff;
                            if(keyData[myStartDate].low < maxDownSize)
                            {
                                trendFound = false;
                            }
                            else if (keyData[myStartDate].high > maxUpSize)
                            {
                                trendFound = false;
                            }


                        current = current+1;
                        myStartDate = dateService.addMinuteToDate(myStartDate, 1);
                    }
                    

                    myStartDate = startDate;

                   

                    while (myEndDate <= endDate) {
                        try {
                            if (!keyData[myEndDate].isEnd) {
                                keyData[myEndDate].isEnd = true;
                                keyData[myEndDate].myhigh = 0;
                                keyData[myEndDate].mylow = 0;
                            }




                            if (myAllData.indexOf(keyData[myStartDate]) < 0)
                                myAllData.push(keyData[myStartDate]);
                            if (myAllData.indexOf(keyData[myEndDate]) < 0)
                                myAllData.push(keyData[myEndDate]);



                            var diff = keyData[myEndDate].close - keyData[myStartDate].close;

                            if (diff > 0) {
                                high = high + 1;
                                avgUp = avgUp + keyData[myStartDate].close;
                                keyData[myEndDate].myhigh++;
                            }
                            else if (diff == 0) {
                                equal = equal + 1;

                            }
                            else {
                                low = low + 1;
                                avgDown = avgDown + keyData[myStartDate].close;
                                keyData[myEndDate].mylow++;
                            }

                            count = count + 1;




                        }
                        catch (ex) {
                            console.error(ex);
                            console.log('error at start ', myStartDate, ' end ', myEndDate);
                        }
                        myStartDate = dateService.addMinuteToDate(myStartDate, 1);
                        myEndDate = dateService.getEndOfDate(myStartDate, config.minutes(), config.endDate15);
                    }

                    var bindModel = {};
                    //get name here
                    bindModel.symbol = item + ' - ' + service.getStockName(item);
                    bindModel.volumeObj = volumeObj;
                    console.log(bindModel.symbol);
                    if (count > 0) {
                        avgDown = avgDown / low;
                        avgUp = avgUp / high;

                        bindModel.error = null;
                        bindModel.high = (high / count) * 100;
                        bindModel.low = (low / count) * 100;
                        bindModel.equal = (equal / count) * 100;
                        bindModel.startDate = startDate;
                        bindModel.endDate = endDate;
                        bindModel.lastPrice = keyData.last.close;
                        bindModel.firstPrice = keyData[startDate].close;
                        bindModel.avgUp = avgUp;
                        bindModel.avgDown = avgDown;

                        bindModel.allData = myAllData;
                        bindModel.foundTrend = trendFound;
                        bindModel.trendDirection = direction;
                    }
                    else {
                        bindModel = {};
                        bindModel.error = 'Not enough data!';
                    }

                    
                    return bindModel;

                };


            })
            .service("cordovaCall", function ($q) {
                var service = this;

                service.callCordova = function () {
                    var deferred = $q.defer();
                    document.addEventListener('deviceready', function () {
                        deferred.resolve();
                    }, false);
                    return deferred.promise;
                };

            })
            .controller("bodyController", function (myModel, $interval, cordovaCall, dateService, $filter, deferSerialService, $q) {
                var body = this;
                body.cordovaCall = cordovaCall;
                body.cordovaCall.callCordova().then(function () {
                    cordova.plugins.backgroundMode.enable();
                });
                body.model = myModel;
                body.config = {
                    minutes: function () {
                        if (this.minutesStr == '')
                            return 0;
                        else
                            return parseInt(this.minutesStr);
                    }
                    , minutesStr: '15'
                    , symbol: 'EURUSD=X'
                    , backMinutes: function () { return this.minutes() * 6; }
                    , symbolDrop: 'EURUSD=X'
                    , endDate15: false
                    , timeToMatch: 0
                    , lastSymbol: ''
                    , alertPercentage:70
                    , timeMinutes : 90
                    , timeHours : 1.5
                };

                body.notifyArray = [];

                body.getMinutesFromHours = function(){
                    body.config.timeMinutes =  Math.ceil(body.config.timeHours * 60);
                };

                 body.getHoursFromMinutes = function(){
                    body.config.timeHours = body.config.timeMinutes / 60;
                };

                body.setShowGraph = function()
                {
                    console.log(body.config.showTodayAverage);
                    if(body.config.showTodayAverage)
                    {
                        body.config.showGraph = true;
                    }

                };

                body.setShowAverage = function()
                {
                    if(!body.config.showGraph)
                    {
                        body.config.showTodayAverage = false;
                    }
                }

                body.showResult = function (config) {
                    //body.clear();
                    config.lastSymbol = config.symbol + ' - '+ body.model.getStockName(config.symbol);
                    body.model.getOneItemData(config.symbol, config).then(function (bindModel) {
                        body.bindModel = bindModel;
                        body.testBindModel(bindModel);



                    });

                };

                body.testBindModel = function (bindModel) {
                    if (!bindModel.error && (((new Date() - bindModel.startDate) / 1000) <= 60)) {
                        bindModel.orderedData = $filter('orderBy')($filter('filter')(bindModel.allData, { isEnd: true }), 'keyDate', true);
                        var isLastUp = bindModel.orderedData.length > (body.config.timeToMatch - 1);
                        if (isLastUp) {
                            for (var i = 0; i < body.config.timeToMatch; i++) {

                                if(body.config.matchReversal)
                                {
                                    isLastUp = isLastUp && bindModel.orderedData[i].myhigh < bindModel.orderedData[i].mylow;
                                }
                                else
                                {
                                    isLastUp = isLastUp && bindModel.orderedData[i].myhigh > bindModel.orderedData[i].mylow;
                                }

                                
                            }
                        }

                        var isLastDown = bindModel.orderedData.length > (body.config.timeToMatch - 1);
                        if (isLastDown) {
                            for (var i = 0; i < body.config.timeToMatch; i++) {
                                if(body.config.matchReversal)
                                {
                                    isLastDown = isLastDown && bindModel.orderedData[i].myhigh > bindModel.orderedData[i].mylow; 
                                }
                                else
                                {
                                    isLastDown = isLastDown && bindModel.orderedData[i].myhigh < bindModel.orderedData[i].mylow;
                                }
                            }
                        }


                        var retObj = {
                            symbol: bindModel.symbol
                , high: bindModel.high
                , equal: bindModel.equal
                , low: bindModel.low
                , startDate: bindModel.startDate
                , trade: ''
                ,volumeObj:bindModel.volumeObj
                        };


                        
                        if (isLastUp
                            && (bindModel.foundTrend && bindModel.trendDirection)) {
                            retObj.trade = 'high';
                            if(body.config.alertPercentage > 0)
                                body.sendNotif('Trade up ' + retObj.symbol);
                            retObj.number = retObj.high;
                            body.notifyArray.push(retObj);
                        }
                        else if (isLastDown
                            && (bindModel.foundTrend && (!bindModel.trendDirection))) {
                            retObj.trade = 'down';
                            if(body.config.alertPercentage > 0)
                                body.sendNotif('Trade down ' + retObj.symbol);
                            retObj.number = retObj.low;
                            
                            body.notifyArray.push(retObj);
                        }
                    }

                };

                body.startTimeoutToAlert = function () {

                    body.timerBody();
                    body.timer = $interval(body.timerBody, 60000);
                };

                body.calcAll = function () {
                    body.notifyArray = [];

                    body.timerBodyLoop();
                };

                body.timerBody = function () {
                    var current = new Date();
                    console.log(current);
                    if ((((current.getMinutes() + 1) % 60) % 15) == 0) {

                        body.notifyArray = [];

                        body.timerBodyLoop();


                    }



                };

                body.timerBodyLoop = function () {
                    var startDef = deferSerialService.getDefObj(function () {
                        var def = $q.defer();
                        def.resolve();
                        return def.promise;
                    }, null);

                    startDef.invoke();
                    angular.forEach(body.model.stocks, function (stock, key) {

                        var stockDef = deferSerialService.getDefObj(function () {
                            var def = $q.defer();
                            //code for one stock;
                            console.log('start ', stock);
                            body.config.lastSymbol = stock.stockSymbol + ' - ' + stock.stockName;
                            body.model.getOneItemData(stock.stockSymbol, body.config).then(function (bindModel) {

                                body.testBindModel(bindModel);
                                console.log('end ', stock);
                                def.resolve();

                            });
                            return def.promise;
                        }, null);
                        startDef.then(stockDef);
                        startDef = stockDef;
                    });
                };



                /*  body.avg = function (arr) {
                      var sum = 0;
                      angular.forEach(arr, function (item, val) {
                          sum = sum + item;
                      });

                      return sum / arr.length;

                  };*/




                body.getEndClass = function (obj) {
                    if (obj.isEnd) {
                        if (obj.myhigh > obj.mylow)
                            return 'success';
                        else if (obj.myhigh == obj.mylow)
                            return 'info';
                        else
                            return 'danger';
                    }
                    else {
                        return '';
                    }
                };

                body.getEndPercentage = function (obj) {
                    if (obj.isEnd) {
                        if (obj.myhigh > obj.mylow)
                            return 100 * (obj.myhigh / (obj.myhigh + obj.mylow));
                        else if (obj.myhigh == obj.mylow)
                            return 0;
                        else
                            return 100 * (obj.mylow / (obj.myhigh + obj.mylow));
                    }
                    else {
                        return '';
                    }
                };

                body.getEndIClass = function (obj) {
                    if (obj.isEnd) {
                        if (obj.myhigh > obj.mylow)
                            return 'glyphicon glyphicon-arrow-up text-success';
                        else if (obj.myhigh == obj.mylow)
                            return '';
                        else
                            return 'glyphicon glyphicon-arrow-down text-danger';;
                    }
                    else {
                        return '';
                    }
                };

                body.sendNotif = function (text) {
                    try {


                        body.cordovaCall.callCordova().then(function () {
                            //beep
                            navigator.notification.beep(1);
                            navigator.vibrate(1000);
                        });

                        body.cordovaCall.callCordova().then(function () {
                            //notification
                            if (body.lastNotificationID) {
                                body.lastNotificationID++;
                            }
                            else {
                                body.lastNotificationID = 1;
                            }
                            cordova.plugins.notification.local.schedule({
                                id: body.lastNotificationID,
                                title: "Trade now!",
                                text: text,


                                //sound: "file://sounds/reminder.mp3",
                                //icon: "http://icons.com/?cal_id=1",

                            });

                        });

                        if (Notification.permission === "granted") {
                            // If it's okay let's create a notification
                            var notification = new Notification(text);
                        }

                            // Otherwise, we need to ask the user for permission
                        else if (Notification.permission !== 'denied') {
                            Notification.requestPermission(function (permission) {
                                // If the user accepts, let's create a notification
                                if (permission === "granted") {
                                    var notification = new Notification(text);
                                }
                            });
                        }
                    }
                    catch (ex) {

                    }

                };





                body.clear = function () {
                    if (body.timer) {
                        $interval.cancel(body.timer);
                        body.timer = null;
                    }
                    body.bindModel = null;
                    body.notifyArray = [];
                };


                body.calculateEndDateOfSelection = function () {
                    var minutes = body.config.minutes();
                    if (minutes > 0) {
                        body.config.endDate = dateService.getDateWithoutSeconds(dateService.getEndOfDate(new Date(), minutes, body.config.endDate15));
                    }
                    else {
                        body.config.endDate = null;
                    }
                };

                body.changeStock = function () {
                    if (body.config.symbolDrop != '') {
                        body.config.symbol = body.config.symbolDrop;
                    }
                };


                //call startup
                body.calculateEndDateOfSelection();


                //body.sendNotif('I am started!');
                //window.setTimeout(function () {
                //    body.sendNotif('I am started after 5 minutes!');
                //}, 300000);


            });


    </script>

    <!-- cordova script (this will be a 404 during development) -->
    <script src="cordova.js"></script>
</head>
<body ng-controller="bodyController as body">
    <div class="row">
        <div class="panel panel-default col-md-12">
            <div class="panel-heading">
                <h3>Fill you input</h3>
            </div>
            <div class="panel-body">
                <form name="calculateForm" novalidate="">
                    <div class="form-group">
                        <label for="timeMinutes" class="control-label">How many minutes to scan ?</label>
                        <input class="form-control" type="number" id="timeMinutes" name="timeMinutes" ng-model="body.config.timeMinutes" ng-change="body.getHoursFromMinutes()"/>
                    </div> 
                    <div class="form-group">
                        <label for="timeHours" class="control-label">How many hours to scan ?</label>
                        <input class="form-control" type="number" id="timeHours" name="timeHours" ng-model="body.config.timeHours" ng-change="body.getMinutesFromHours()"/>
                    </div> 
                    <div class="form-group">
                        <label for="minutes" class="control-label">How many minutes to check last ?</label>
                        <select name="minutes" ng-model="body.config.minutesStr" ng-change="body.calculateEndDateOfSelection()" class="form-control">
                            <option value="">Select</option>
                            <option value="01">01 minutes</option>
                            <option value="02">02 minutes</option>
                             <option value="03">03 minutes</option>
                             <option value="04">04 minutes</option>
                            <option value="05">05 minutes</option>
                            <option value="13">13 minutes</option>
                            <option value="15">15 minutes</option>
                            <option value="28">28 minutes</option>
                            <option value="30">30 minutes</option>
                            <option value="43">43 minutes</option>
                            <option value="45">45 minutes</option>
                            <option value="60">60 minutes</option>
                            <option value="75">75 minutes</option>
                            <option value="90">90 minutes</option>
                            <option value="105">105 minutes</option>
                            <option value="120">120 minutes</option>
                        </select>
                        <div class="text-info">
                            <i class="glyphicon glyphicon-time text-info"></i> End time :  {{ body.config.endDate}}
                        </div>
                    </div>

                    <div class="form-group">
                        <label for="symbol" lass="control-label">Stock/Forex Name ?</label>
                        <input type="text" name="symbol" ng-model="body.config.symbol" class="form-control" required>
                    </div>

                    <div class="form-group">
                        <label for="symbolDrop" lass="control-label">Stock/Forex Name ? (Select)</label>
                        <select name="symbolDrop" class="form-control" ng-change="body.changeStock()" ng-model="body.config.symbolDrop">
                            <option value="">Select</option>
                            <option ng-repeat="stock in body.model.stocks" value="{{stock.stockSymbol}}">
                                {{stock.stockName}}
                            </option>

                        </select>
                    </div>

                    <div class="form-group">
                        <label for="backMinutes" lass="control-label">How many minutes back ?</label>
                        <input disabled="disabled" readonly="readonly" type="text" name="backMinutes" value="{{body.config.backMinutes()}}" class="form-control">
                    </div>
                    <div class="form-group">
                        <label for="timeToMatch" lass="control-label">How many minutes match ?</label>
                        <input type="text" name="timeToMatch" ng-model="body.config.timeToMatch" class="form-control" required>
                    </div>

                    <div class="form-group">

                            <div class="btn-group">
                                <label class="btn btn-default">
                                    <input type="checkbox" name="matchReversal" id="matchReversal" ng-model="body.config.matchReversal">
                                    Time to match reverse ?
                                    
                                </label>
                            </div>
                    </div>





                     <div class="form-group">

                        <label for="alertPercentage" lass="control-label">Percentage to match</label>
                        <input type="text" name="alertPercentage" ng-model="body.config.alertPercentage" class="form-control" required>

                    </div>

                    <style>
                        .my-check-containter > .btn-group
                        {
                            margin:5px;
                        }
                    </style>
                    <div class="my-check-containter form-group">

                        <div class="btn-group">
                            <label class="btn btn-default">
                                <input type="checkbox" name="showGraph" id="showGraph" ng-model="body.config.showGraph" ng-change="body.setShowAverage();">

                                show graphs ?
                            </label>
                        </div>

                         <div class="btn-group">
                            <label class="btn btn-default">
                                <input type="checkbox" name="showDayGraph" id="showDayGraph" ng-model="body.config.showDayGraph">

                                show day graph ?
                            </label>
                        </div>

                        <div class="btn-group">
                            <label class="btn btn-default">
                                <input type="checkbox" name="showAverageLine" id="showAverageLine" ng-model="body.config.showAverageLine">

                                show average line ?
                            </label>
                        </div>

                         <div class="btn-group">
                            <label class="btn btn-default">
                                <input type="checkbox" name="showTodayAverage" id="showTodayAverage" ng-model="body.config.showTodayAverage" ng-change="body.setShowGraph();">

                                show average and today divergance ?
                            </label>
                        </div>

                         <div class="btn-group">
                            <label class="btn btn-default">
                                <input type="checkbox" name="showVol" id="showVol" ng-model="body.config.showVolume">

                                show volume graph ?
                            </label>
                        </div>

                         <div class="btn-group">
                            <label class="btn btn-default">
                                <input type="checkbox" name="showOvb" id="showOvb" ng-model="body.config.showOvb">

                                show ovb graph ?
                            </label>
                        </div>

                         <div class="btn-group">
                            <label class="btn btn-default">
                                <input type="checkbox" name="showEnhanceOvb" id="showEnhanceOvb" ng-model="body.config.showEOvb">

                                show enhanced ovb graph ?
                            </label>
                        </div>

                         <div class="btn-group">
                            <label class="btn btn-default">
                                <input type="checkbox" name="endDate15" id="endDate15" ng-model="body.config.endDate15">

                                Normalize to 15 ?
                            </label>
                        </div>

                    </div>

 
                   


                    <div class="form-group">
                        <button class="btn btn-success" ng-disabled="!calculateForm.$valid" ng-click="body.showResult(body.config)">Calculate</button>
                    </div>
                    <div class="form-group">
                        <button class="btn btn-danger" ng-click="body.clear()">Clear Results</button>
                    </div>
                    <div class="form-group">
                        <button class="btn btn-default" ng-click="body.startTimeoutToAlert()" ng-disabled="body.timer">Start Listen</button>
                    </div>

                    <div class="form-group">
                        <button class="btn btn-default" ng-click="body.calcAll()">Calc All</button>
                    </div>
                </form>

                <div>
                    Last symbol : {{body.config.lastSymbol}}
                </div>

                <div ng-show="body.notifyArray.length > 0">
                    <ul>
                        <li ng-repeat="item in body.notifyArray  | orderBy:'number':true">
                            Name : {{item.symbol}}<br>
                            Date : {{item.startDate}}<br>
                            High : {{item.high | number:5}} %<br>
                            Equal : {{item.equal | number:5}} %<br>
                            Low : {{item.low | number:5}} %<br>
                            Trade : {{item.trade}}<br>
                            Avg Volume : {{item.volumeObj.avgVolume | number:2}}<br>
                            <div ng-if="body.config.showGraph">
                                 graph : 
                                <canvas id="graphLine1" class="chart chart-line" chart-data="item.volumeObj.closesChart.data" chart-labels="item.volumeObj.closesChart.labels" chart-series="item.volumeObj.closesChart.series" chart-options="item.volumeObj.closesChart.options" chart-dataset-override="item.volumeObj.closesChart.dataset">
                                </canvas>
                            </div>

                            <br>

                             <div ng-if="body.config.showDayGraph">
                                 all day : 
                                <canvas id="dayGraphLine1" class="chart chart-line" chart-data="item.volumeObj.dayGraph.data" chart-labels="item.volumeObj.dayGraph.labels" chart-series="item.volumeObj.dayGraph.series" chart-options="item.volumeObj.dayGraph.options" chart-dataset-override="item.volumeObj.dayGraph.dataset">
                                </canvas>
                            </div>
                           

                             <br>

<div ng-if="body.config.showVolume">
     vol : 
                            
                           


<canvas id="volumeLine1" class="chart chart-bar" chart-data="item.volumeObj.volumeChart.data" chart-labels="item.volumeObj.volumeChart.labels" chart-series="item.volumeObj.volumeChart.series">
</canvas>
</div>
<br>

                            <div ng-if="body.config.showOvb">
                               


                            ovb : 
                            

                            
<canvas id="ovbLine1" class="chart chart-line" chart-data="item.volumeObj.ovbChart.data" chart-labels="item.volumeObj.ovbChart.labels" chart-series="item.volumeObj.ovbChart.series" chart-options="item.volumeObj.ovbChart.options" chart-dataset-override="item.volumeObj.ovbChart.dataset">
</canvas>
                            </div>
                            
                            <br>
                             <div ng-if="body.config.showEOvb">
                               


                            Enhanced ovb : 
                            

                            
<canvas id="eovbLine1" class="chart chart-line" chart-data="item.volumeObj.enhanceOvbChart.data" chart-labels="item.volumeObj.enhanceOvbChart.labels" chart-series="item.volumeObj.enhanceOvbChart.series" chart-options="item.volumeObj.enhanceOvbChart.options" chart-dataset-override="item.volumeObj.enhanceOvbChart.dataset">
</canvas>
                            </div>

                        
                        </li>
                    </ul>
                </div>


                <div ng-show="body.bindModel && !body.bindModel.error">



                    <hr ng-show="body.bindModel">



                    <h3 ng-show="body.bindModel">Result :</h3>
                    <table ng-show="body.bindModel">
                        <tr>
                            <td>
                                Live price
                            </td>
                            <td>
                                {{body.updatedPrice | number:5}}
                            </td>
                        </tr>
                        <tr>
                            <td>First price</td>
                            <td>{{body.bindModel.firstPrice | number:5}} </td>
                        </tr>
                        <tr>
                            <td>Last price</td>
                            <td>{{body.bindModel.lastPrice | number:5}} </td>
                        </tr>
                        <tr>
                            <td>From</td>
                            <td>{{body.bindModel.startDate}}</td>
                        </tr>
                        <tr>
                            <td>To</td>
                            <td>{{body.bindModel.endDate}}</td>
                        </tr>
                        <tr>
                            <td>Low percentage</td>
                            <td><i ng-show="body.bindModel.low" class="glyphicon glyphicon-arrow-down text-danger"></i> {{body.bindModel.low | number:2}}  % <br> Buy h than  : {{body.bindModel.avgDown | number:5}}</td>
                        </tr>
                        <tr>
                            <td>High percentage</td>
                            <td><i ng-show="body.bindModel.high" class="glyphicon glyphicon-arrow-up text-success"></i> {{body.bindModel.high | number:2}}  % <br> buy l than  : {{body.bindModel.avgUp | number:5}}</td>
                        </tr>
                        <tr>
                            <td>equality percentage</td>
                            <td> {{body.bindModel.equal | number:2}} %</td>
                        </tr>
                         <tr>
                            <td>Avg Volume</td>
                            <td> {{body.bindModel.volumeObj.avgVolume | number:2}} </td>
                        </tr>
                        <tr ng-if="body.config.showGraph">
                            <td>
                                graph
                            </td>
                            <td style="width:100%">
                                 <canvas id="graphLine2" class="chart chart-line" chart-data="body.bindModel.volumeObj.closesChart.data" chart-labels="body.bindModel.volumeObj.closesChart.labels" chart-series="body.bindModel.volumeObj.closesChart.series" chart-options="body.bindModel.volumeObj.closesChart.options" chart-dataset-override="body.bindModel.volumeObj.closesChart.dataset">
</canvas>
                            </td>
                        </tr>
                        <tr ng-if="body.config.showDayGraph">
                            <td>
                                all day
                            </td>
                            <td style="width:100%">
                                 <canvas id="dayGraphLine2" class="chart chart-line" chart-data="body.bindModel.volumeObj.dayGraph.data" chart-labels="body.bindModel.volumeObj.dayGraph.labels" chart-series="body.bindModel.volumeObj.dayGraph.series" chart-options="body.bindModel.volumeObj.dayGraph.options" chart-dataset-override="body.bindModel.volumeObj.dayGraph.dataset">
                                </canvas>
                            </td>
                        </tr>
                        <tr ng-if="body.config.showVolume">
                            <td>
                                vol
                            </td>
                            <td style="width:100%">
                                <canvas id="volumeLine2" class="chart chart-bar" chart-data="body.bindModel.volumeObj.volumeChart.data" chart-labels="body.bindModel.volumeObj.volumeChart.labels" chart-series="body.bindModel.volumeObj.volumeChart.series">
</canvas>
                            </td>
                           
                        </tr>
                        <tr ng-if="body.config.showOvb">
                            <td>
                                ovb
                            </td>
                             <td style="width:100%">
                                
                           <canvas id="ovbLine2" class="chart chart-line" chart-data="body.bindModel.volumeObj.ovbChart.data" chart-labels="body.bindModel.volumeObj.ovbChart.labels" chart-series="body.bindModel.volumeObj.ovbChart.series" chart-options="body.bindModel.volumeObj.ovbChart.options" chart-dataset-override="body.bindModel.volumeObj.ovbChart.dataset">
</canvas>
                            </td>
                        </tr>

 <tr ng-if="body.config.showEOvb">
                            <td>
                                Enhanced ovb
                            </td>
                             <td style="width:100%">
                                
                           <canvas id="eovbLine2" class="chart chart-line" chart-data="body.bindModel.volumeObj.enhanceOvbChart.data" chart-labels="body.bindModel.volumeObj.enhanceOvbChart.labels" chart-series="body.bindModel.volumeObj.enhanceOvbChart.series" chart-options="body.bindModel.volumeObj.enhanceOvbChart.options" chart-dataset-override="body.bindModel.volumeObj.enhanceOvbChart.dataset">
</canvas>
                            </td>
                        </tr>

                        
                    </table>

                    <hr>

                    <h2>values :</h2>
                    <table class="table">
                        <thead>
                            <tr>
                                <th>
                                    time
                                </th>
                                <th>
                                    close
                                </th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr ng-class="body.getEndClass(item)" ng-repeat="item in body.bindModel.allData | orderBy:'keyDate':true">
                                <td>
                                    {{item.keyDate}}
                                    <i ng-class="body.getEndIClass(item)"></i>
                                    {{body.getEndPercentage(item) | number:2}} %
                                    {{item.isEnd}}
                                </td>
                                <td>
                                    {{item.close | number:5}}
                                </td>
                            </tr>
                        </tbody>

                    </table>
                </div>

                <div ng-show="body.bindModel && body.bindModel.error" class="text-danger">
                    {{body.bindModel.error}}
                </div>

            </div>
        </div>
    </div>




</body>
</html>
